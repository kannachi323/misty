// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: minidfs.proto

package minidfs

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FileOpType int32

const (
	FileOpType_READ  FileOpType = 0
	FileOpType_WRITE FileOpType = 1
	FileOpType_DEL   FileOpType = 2
)

// Enum value maps for FileOpType.
var (
	FileOpType_name = map[int32]string{
		0: "READ",
		1: "WRITE",
		2: "DEL",
	}
	FileOpType_value = map[string]int32{
		"READ":  0,
		"WRITE": 1,
		"DEL":   2,
	}
)

func (x FileOpType) Enum() *FileOpType {
	p := new(FileOpType)
	*p = x
	return p
}

func (x FileOpType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileOpType) Descriptor() protoreflect.EnumDescriptor {
	return file_minidfs_proto_enumTypes[0].Descriptor()
}

func (FileOpType) Type() protoreflect.EnumType {
	return &file_minidfs_proto_enumTypes[0]
}

func (x FileOpType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileOpType.Descriptor instead.
func (FileOpType) EnumDescriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{0}
}

type FileUpdateType int32

const (
	FileUpdateType_CREATED  FileUpdateType = 0
	FileUpdateType_MODIFIED FileUpdateType = 1
	FileUpdateType_DELETED  FileUpdateType = 2
)

// Enum value maps for FileUpdateType.
var (
	FileUpdateType_name = map[int32]string{
		0: "CREATED",
		1: "MODIFIED",
		2: "DELETED",
	}
	FileUpdateType_value = map[string]int32{
		"CREATED":  0,
		"MODIFIED": 1,
		"DELETED":  2,
	}
)

func (x FileUpdateType) Enum() *FileUpdateType {
	p := new(FileUpdateType)
	*p = x
	return p
}

func (x FileUpdateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileUpdateType) Descriptor() protoreflect.EnumDescriptor {
	return file_minidfs_proto_enumTypes[1].Descriptor()
}

func (FileUpdateType) Type() protoreflect.EnumType {
	return &file_minidfs_proto_enumTypes[1]
}

func (x FileUpdateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileUpdateType.Descriptor instead.
func (FileUpdateType) EnumDescriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{1}
}

type FileBuffer struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Offset        uint64                 `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileBuffer) Reset() {
	*x = FileBuffer{}
	mi := &file_minidfs_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileBuffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileBuffer) ProtoMessage() {}

func (x *FileBuffer) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileBuffer.ProtoReflect.Descriptor instead.
func (*FileBuffer) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{0}
}

func (x *FileBuffer) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *FileBuffer) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileBuffer) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *FileBuffer) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type FileInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilePath      string                 `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Mtime         uint64                 `protobuf:"varint,3,opt,name=mtime,proto3" json:"mtime,omitempty"`
	IsDir         bool                   `protobuf:"varint,4,opt,name=is_dir,json=isDir,proto3" json:"is_dir,omitempty"`
	Hash          string                 `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileInfo) Reset() {
	*x = FileInfo{}
	mi := &file_minidfs_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileInfo) ProtoMessage() {}

func (x *FileInfo) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileInfo.ProtoReflect.Descriptor instead.
func (*FileInfo) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{1}
}

func (x *FileInfo) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileInfo) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FileInfo) GetMtime() uint64 {
	if x != nil {
		return x.Mtime
	}
	return 0
}

func (x *FileInfo) GetIsDir() bool {
	if x != nil {
		return x.IsDir
	}
	return false
}

func (x *FileInfo) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

type ListFilesReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesReq) Reset() {
	*x = ListFilesReq{}
	mi := &file_minidfs_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesReq) ProtoMessage() {}

func (x *ListFilesReq) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesReq.ProtoReflect.Descriptor instead.
func (*ListFilesReq) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{2}
}

func (x *ListFilesReq) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type ListFilesRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Files         []*FileInfo            `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesRes) Reset() {
	*x = ListFilesRes{}
	mi := &file_minidfs_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesRes) ProtoMessage() {}

func (x *ListFilesRes) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesRes.ProtoReflect.Descriptor instead.
func (*ListFilesRes) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{3}
}

func (x *ListFilesRes) GetFiles() []*FileInfo {
	if x != nil {
		return x.Files
	}
	return nil
}

type StoreFileRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Msg           string                 `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoreFileRes) Reset() {
	*x = StoreFileRes{}
	mi := &file_minidfs_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoreFileRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreFileRes) ProtoMessage() {}

func (x *StoreFileRes) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreFileRes.ProtoReflect.Descriptor instead.
func (*StoreFileRes) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{4}
}

func (x *StoreFileRes) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

func (x *StoreFileRes) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type FetchFileReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchFileReq) Reset() {
	*x = FetchFileReq{}
	mi := &file_minidfs_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchFileReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchFileReq) ProtoMessage() {}

func (x *FetchFileReq) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchFileReq.ProtoReflect.Descriptor instead.
func (*FetchFileReq) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{5}
}

func (x *FetchFileReq) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *FetchFileReq) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type DeleteFileReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileReq) Reset() {
	*x = DeleteFileReq{}
	mi := &file_minidfs_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileReq) ProtoMessage() {}

func (x *DeleteFileReq) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileReq.ProtoReflect.Descriptor instead.
func (*DeleteFileReq) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{6}
}

func (x *DeleteFileReq) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *DeleteFileReq) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type DeleteFileRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Msg           string                 `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileRes) Reset() {
	*x = DeleteFileRes{}
	mi := &file_minidfs_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileRes) ProtoMessage() {}

func (x *DeleteFileRes) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileRes.ProtoReflect.Descriptor instead.
func (*DeleteFileRes) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{7}
}

func (x *DeleteFileRes) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

func (x *DeleteFileRes) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type FileLockReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Op            FileOpType             `protobuf:"varint,3,opt,name=op,proto3,enum=minidfs.FileOpType" json:"op,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileLockReq) Reset() {
	*x = FileLockReq{}
	mi := &file_minidfs_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileLockReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileLockReq) ProtoMessage() {}

func (x *FileLockReq) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileLockReq.ProtoReflect.Descriptor instead.
func (*FileLockReq) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{8}
}

func (x *FileLockReq) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *FileLockReq) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileLockReq) GetOp() FileOpType {
	if x != nil {
		return x.Op
	}
	return FileOpType_READ
}

type FileLockRes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileLockRes) Reset() {
	*x = FileLockRes{}
	mi := &file_minidfs_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileLockRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileLockRes) ProtoMessage() {}

func (x *FileLockRes) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileLockRes.ProtoReflect.Descriptor instead.
func (*FileLockRes) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{9}
}

func (x *FileLockRes) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type FileUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Type          FileUpdateType         `protobuf:"varint,2,opt,name=type,proto3,enum=minidfs.FileUpdateType" json:"type,omitempty"`
	FileInfo      *FileInfo              `protobuf:"bytes,3,opt,name=file_info,json=fileInfo,proto3" json:"file_info,omitempty"`
	Version       uint64                 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileUpdate) Reset() {
	*x = FileUpdate{}
	mi := &file_minidfs_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileUpdate) ProtoMessage() {}

func (x *FileUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_minidfs_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileUpdate.ProtoReflect.Descriptor instead.
func (*FileUpdate) Descriptor() ([]byte, []int) {
	return file_minidfs_proto_rawDescGZIP(), []int{10}
}

func (x *FileUpdate) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *FileUpdate) GetType() FileUpdateType {
	if x != nil {
		return x.Type
	}
	return FileUpdateType_CREATED
}

func (x *FileUpdate) GetFileInfo() *FileInfo {
	if x != nil {
		return x.FileInfo
	}
	return nil
}

func (x *FileUpdate) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

var File_minidfs_proto protoreflect.FileDescriptor

const file_minidfs_proto_rawDesc = "" +
	"\n" +
	"\rminidfs.proto\x12\aminidfs\"r\n" +
	"\n" +
	"FileBuffer\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x16\n" +
	"\x06offset\x18\x04 \x01(\x04R\x06offset\"|\n" +
	"\bFileInfo\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x14\n" +
	"\x05mtime\x18\x03 \x01(\x04R\x05mtime\x12\x15\n" +
	"\x06is_dir\x18\x04 \x01(\bR\x05isDir\x12\x12\n" +
	"\x04hash\x18\x05 \x01(\tR\x04hash\"\"\n" +
	"\fListFilesReq\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\"7\n" +
	"\fListFilesRes\x12'\n" +
	"\x05files\x18\x01 \x03(\v2\x11.minidfs.FileInfoR\x05files\":\n" +
	"\fStoreFileRes\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\tR\x03msg\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\"H\n" +
	"\fFetchFileReq\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\"I\n" +
	"\rDeleteFileReq\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\";\n" +
	"\rDeleteFileRes\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\tR\x03msg\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\"l\n" +
	"\vFileLockReq\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12#\n" +
	"\x02op\x18\x03 \x01(\x0e2\x13.minidfs.FileOpTypeR\x02op\"'\n" +
	"\vFileLockRes\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\"\xa0\x01\n" +
	"\n" +
	"FileUpdate\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12+\n" +
	"\x04type\x18\x02 \x01(\x0e2\x17.minidfs.FileUpdateTypeR\x04type\x12.\n" +
	"\tfile_info\x18\x03 \x01(\v2\x11.minidfs.FileInfoR\bfileInfo\x12\x18\n" +
	"\aversion\x18\x04 \x01(\x04R\aversion**\n" +
	"\n" +
	"FileOpType\x12\b\n" +
	"\x04READ\x10\x00\x12\t\n" +
	"\x05WRITE\x10\x01\x12\a\n" +
	"\x03DEL\x10\x02*8\n" +
	"\x0eFileUpdateType\x12\v\n" +
	"\aCREATED\x10\x00\x12\f\n" +
	"\bMODIFIED\x10\x01\x12\v\n" +
	"\aDELETED\x10\x022\xfc\x02\n" +
	"\x0eMiniDFSService\x129\n" +
	"\tListFiles\x12\x15.minidfs.ListFilesReq\x1a\x15.minidfs.ListFilesRes\x129\n" +
	"\tStoreFile\x12\x13.minidfs.FileBuffer\x1a\x15.minidfs.StoreFileRes(\x01\x129\n" +
	"\tFetchFile\x12\x15.minidfs.FetchFileReq\x1a\x13.minidfs.FileBuffer0\x01\x129\n" +
	"\vGetFileLock\x12\x14.minidfs.FileLockReq\x1a\x14.minidfs.FileLockRes\x12<\n" +
	"\n" +
	"RemoveFile\x12\x16.minidfs.DeleteFileReq\x1a\x16.minidfs.DeleteFileRes\x12@\n" +
	"\x12FileUpdateCallback\x12\x13.minidfs.FileUpdate\x1a\x13.minidfs.FileUpdate0\x01B\vZ\t.;minidfsb\x06proto3"

var (
	file_minidfs_proto_rawDescOnce sync.Once
	file_minidfs_proto_rawDescData []byte
)

func file_minidfs_proto_rawDescGZIP() []byte {
	file_minidfs_proto_rawDescOnce.Do(func() {
		file_minidfs_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_minidfs_proto_rawDesc), len(file_minidfs_proto_rawDesc)))
	})
	return file_minidfs_proto_rawDescData
}

var file_minidfs_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_minidfs_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_minidfs_proto_goTypes = []any{
	(FileOpType)(0),       // 0: minidfs.FileOpType
	(FileUpdateType)(0),   // 1: minidfs.FileUpdateType
	(*FileBuffer)(nil),    // 2: minidfs.FileBuffer
	(*FileInfo)(nil),      // 3: minidfs.FileInfo
	(*ListFilesReq)(nil),  // 4: minidfs.ListFilesReq
	(*ListFilesRes)(nil),  // 5: minidfs.ListFilesRes
	(*StoreFileRes)(nil),  // 6: minidfs.StoreFileRes
	(*FetchFileReq)(nil),  // 7: minidfs.FetchFileReq
	(*DeleteFileReq)(nil), // 8: minidfs.DeleteFileReq
	(*DeleteFileRes)(nil), // 9: minidfs.DeleteFileRes
	(*FileLockReq)(nil),   // 10: minidfs.FileLockReq
	(*FileLockRes)(nil),   // 11: minidfs.FileLockRes
	(*FileUpdate)(nil),    // 12: minidfs.FileUpdate
}
var file_minidfs_proto_depIdxs = []int32{
	3,  // 0: minidfs.ListFilesRes.files:type_name -> minidfs.FileInfo
	0,  // 1: minidfs.FileLockReq.op:type_name -> minidfs.FileOpType
	1,  // 2: minidfs.FileUpdate.type:type_name -> minidfs.FileUpdateType
	3,  // 3: minidfs.FileUpdate.file_info:type_name -> minidfs.FileInfo
	4,  // 4: minidfs.MiniDFSService.ListFiles:input_type -> minidfs.ListFilesReq
	2,  // 5: minidfs.MiniDFSService.StoreFile:input_type -> minidfs.FileBuffer
	7,  // 6: minidfs.MiniDFSService.FetchFile:input_type -> minidfs.FetchFileReq
	10, // 7: minidfs.MiniDFSService.GetFileLock:input_type -> minidfs.FileLockReq
	8,  // 8: minidfs.MiniDFSService.RemoveFile:input_type -> minidfs.DeleteFileReq
	12, // 9: minidfs.MiniDFSService.FileUpdateCallback:input_type -> minidfs.FileUpdate
	5,  // 10: minidfs.MiniDFSService.ListFiles:output_type -> minidfs.ListFilesRes
	6,  // 11: minidfs.MiniDFSService.StoreFile:output_type -> minidfs.StoreFileRes
	2,  // 12: minidfs.MiniDFSService.FetchFile:output_type -> minidfs.FileBuffer
	11, // 13: minidfs.MiniDFSService.GetFileLock:output_type -> minidfs.FileLockRes
	9,  // 14: minidfs.MiniDFSService.RemoveFile:output_type -> minidfs.DeleteFileRes
	12, // 15: minidfs.MiniDFSService.FileUpdateCallback:output_type -> minidfs.FileUpdate
	10, // [10:16] is the sub-list for method output_type
	4,  // [4:10] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_minidfs_proto_init() }
func file_minidfs_proto_init() {
	if File_minidfs_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_minidfs_proto_rawDesc), len(file_minidfs_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_minidfs_proto_goTypes,
		DependencyIndexes: file_minidfs_proto_depIdxs,
		EnumInfos:         file_minidfs_proto_enumTypes,
		MessageInfos:      file_minidfs_proto_msgTypes,
	}.Build()
	File_minidfs_proto = out.File
	file_minidfs_proto_goTypes = nil
	file_minidfs_proto_depIdxs = nil
}
