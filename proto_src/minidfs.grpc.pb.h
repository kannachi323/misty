// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minidfs.proto
#ifndef GRPC_minidfs_2eproto__INCLUDED
#define GRPC_minidfs_2eproto__INCLUDED

#include "minidfs.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace minidfs {

// service methods for minidfs
class MiniDFSService final {
 public:
  static constexpr char const* service_full_name() {
    return "minidfs.MiniDFSService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // List files in a directory
    virtual ::grpc::Status ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::minidfs::ListFilesRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>> AsyncListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>>(AsyncListFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>> PrepareAsyncListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>>(PrepareAsyncListFilesRaw(context, request, cq));
    }
    // Store files on the server
    std::unique_ptr< ::grpc::ClientWriterInterface< ::minidfs::FileBuffer>> StoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::minidfs::FileBuffer>>(StoreFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>> AsyncStoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>>(AsyncStoreFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>> PrepareAsyncStoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>>(PrepareAsyncStoreFileRaw(context, response, cq));
    }
    // Fetch files from the server
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minidfs::FileBuffer>> FetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minidfs::FileBuffer>>(FetchFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>> AsyncFetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>>(AsyncFetchFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>> PrepareAsyncFetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>>(PrepareAsyncFetchFileRaw(context, request, cq));
    }
    // Get a file lock
    virtual ::grpc::Status GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::minidfs::FileLockRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>> AsyncGetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>>(AsyncGetFileLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>> PrepareAsyncGetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>>(PrepareAsyncGetFileLockRaw(context, request, cq));
    }
    // Delete file request
    virtual ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::minidfs::DeleteFileRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>> AsyncRemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    // Callback for file updates
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minidfs::FileUpdate>> FileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minidfs::FileUpdate>>(FileUpdateCallbackRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>> AsyncFileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>>(AsyncFileUpdateCallbackRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>> PrepareAsyncFileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>>(PrepareAsyncFileUpdateCallbackRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // List files in a directory
      virtual void ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Store files on the server
      virtual void StoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::ClientWriteReactor< ::minidfs::FileBuffer>* reactor) = 0;
      // Fetch files from the server
      virtual void FetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq* request, ::grpc::ClientReadReactor< ::minidfs::FileBuffer>* reactor) = 0;
      // Get a file lock
      virtual void GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Delete file request
      virtual void RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Callback for file updates
      virtual void FileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate* request, ::grpc::ClientReadReactor< ::minidfs::FileUpdate>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>* AsyncListFilesRaw(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::ListFilesRes>* PrepareAsyncListFilesRaw(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::minidfs::FileBuffer>* StoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>* AsyncStoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::minidfs::FileBuffer>* PrepareAsyncStoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minidfs::FileBuffer>* FetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>* AsyncFetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minidfs::FileBuffer>* PrepareAsyncFetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>* AsyncGetFileLockRaw(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::FileLockRes>* PrepareAsyncGetFileLockRaw(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minidfs::DeleteFileRes>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minidfs::FileUpdate>* FileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>* AsyncFileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minidfs::FileUpdate>* PrepareAsyncFileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::minidfs::ListFilesRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>> AsyncListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>>(AsyncListFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>> PrepareAsyncListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>>(PrepareAsyncListFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::minidfs::FileBuffer>> StoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::minidfs::FileBuffer>>(StoreFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>> AsyncStoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>>(AsyncStoreFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>> PrepareAsyncStoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>>(PrepareAsyncStoreFileRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minidfs::FileBuffer>> FetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minidfs::FileBuffer>>(FetchFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>> AsyncFetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>>(AsyncFetchFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>> PrepareAsyncFetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>>(PrepareAsyncFetchFileRaw(context, request, cq));
    }
    ::grpc::Status GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::minidfs::FileLockRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>> AsyncGetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>>(AsyncGetFileLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>> PrepareAsyncGetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>>(PrepareAsyncGetFileLockRaw(context, request, cq));
    }
    ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::minidfs::DeleteFileRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>> AsyncRemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minidfs::FileUpdate>> FileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minidfs::FileUpdate>>(FileUpdateCallbackRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>> AsyncFileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>>(AsyncFileUpdateCallbackRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>> PrepareAsyncFileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>>(PrepareAsyncFileUpdateCallbackRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response, std::function<void(::grpc::Status)>) override;
      void ListFiles(::grpc::ClientContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StoreFile(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::ClientWriteReactor< ::minidfs::FileBuffer>* reactor) override;
      void FetchFile(::grpc::ClientContext* context, const ::minidfs::FetchFileReq* request, ::grpc::ClientReadReactor< ::minidfs::FileBuffer>* reactor) override;
      void GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response, std::function<void(::grpc::Status)>) override;
      void GetFileLock(::grpc::ClientContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response, std::function<void(::grpc::Status)>) override;
      void RemoveFile(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FileUpdateCallback(::grpc::ClientContext* context, const ::minidfs::FileUpdate* request, ::grpc::ClientReadReactor< ::minidfs::FileUpdate>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>* AsyncListFilesRaw(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minidfs::ListFilesRes>* PrepareAsyncListFilesRaw(::grpc::ClientContext* context, const ::minidfs::ListFilesReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::minidfs::FileBuffer>* StoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response) override;
    ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>* AsyncStoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::minidfs::FileBuffer>* PrepareAsyncStoreFileRaw(::grpc::ClientContext* context, ::minidfs::StoreFileRes* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minidfs::FileBuffer>* FetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request) override;
    ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>* AsyncFetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minidfs::FileBuffer>* PrepareAsyncFetchFileRaw(::grpc::ClientContext* context, const ::minidfs::FetchFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>* AsyncGetFileLockRaw(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minidfs::FileLockRes>* PrepareAsyncGetFileLockRaw(::grpc::ClientContext* context, const ::minidfs::FileLockReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minidfs::DeleteFileRes>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::minidfs::DeleteFileReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minidfs::FileUpdate>* FileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request) override;
    ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>* AsyncFileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minidfs::FileUpdate>* PrepareAsyncFileUpdateCallbackRaw(::grpc::ClientContext* context, const ::minidfs::FileUpdate& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreFile_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFileLock_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveFile_;
    const ::grpc::internal::RpcMethod rpcmethod_FileUpdateCallback_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // List files in a directory
    virtual ::grpc::Status ListFiles(::grpc::ServerContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response);
    // Store files on the server
    virtual ::grpc::Status StoreFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::minidfs::FileBuffer>* reader, ::minidfs::StoreFileRes* response);
    // Fetch files from the server
    virtual ::grpc::Status FetchFile(::grpc::ServerContext* context, const ::minidfs::FetchFileReq* request, ::grpc::ServerWriter< ::minidfs::FileBuffer>* writer);
    // Get a file lock
    virtual ::grpc::Status GetFileLock(::grpc::ServerContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response);
    // Delete file request
    virtual ::grpc::Status RemoveFile(::grpc::ServerContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response);
    // Callback for file updates
    virtual ::grpc::Status FileUpdateCallback(::grpc::ServerContext* context, const ::minidfs::FileUpdate* request, ::grpc::ServerWriter< ::minidfs::FileUpdate>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListFiles() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFiles(::grpc::ServerContext* context, ::minidfs::ListFilesReq* request, ::grpc::ServerAsyncResponseWriter< ::minidfs::ListFilesRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StoreFile() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StoreFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::minidfs::FileBuffer>* /*reader*/, ::minidfs::StoreFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::minidfs::StoreFileRes, ::minidfs::FileBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFile(::grpc::ServerContext* context, ::minidfs::FetchFileReq* request, ::grpc::ServerAsyncWriter< ::minidfs::FileBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFileLock() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileLock(::grpc::ServerContext* context, ::minidfs::FileLockReq* request, ::grpc::ServerAsyncResponseWriter< ::minidfs::FileLockRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveFile() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::minidfs::DeleteFileReq* request, ::grpc::ServerAsyncResponseWriter< ::minidfs::DeleteFileRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileUpdateCallback(::grpc::ServerContext* context, ::minidfs::FileUpdate* request, ::grpc::ServerAsyncWriter< ::minidfs::FileUpdate>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListFiles<WithAsyncMethod_StoreFile<WithAsyncMethod_FetchFile<WithAsyncMethod_GetFileLock<WithAsyncMethod_RemoveFile<WithAsyncMethod_FileUpdateCallback<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListFiles() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minidfs::ListFilesReq, ::minidfs::ListFilesRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minidfs::ListFilesReq* request, ::minidfs::ListFilesRes* response) { return this->ListFiles(context, request, response); }));}
    void SetMessageAllocatorFor_ListFiles(
        ::grpc::MessageAllocator< ::minidfs::ListFilesReq, ::minidfs::ListFilesRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minidfs::ListFilesReq, ::minidfs::ListFilesRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StoreFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StoreFile() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::minidfs::FileBuffer, ::minidfs::StoreFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, ::minidfs::StoreFileRes* response) { return this->StoreFile(context, response); }));
    }
    ~WithCallbackMethod_StoreFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::minidfs::FileBuffer>* /*reader*/, ::minidfs::StoreFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::minidfs::FileBuffer>* StoreFile(
      ::grpc::CallbackServerContext* /*context*/, ::minidfs::StoreFileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FetchFile() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minidfs::FetchFileReq, ::minidfs::FileBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minidfs::FetchFileReq* request) { return this->FetchFile(context, request); }));
    }
    ~WithCallbackMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minidfs::FileBuffer>* FetchFile(
      ::grpc::CallbackServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFileLock() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minidfs::FileLockReq, ::minidfs::FileLockRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minidfs::FileLockReq* request, ::minidfs::FileLockRes* response) { return this->GetFileLock(context, request, response); }));}
    void SetMessageAllocatorFor_GetFileLock(
        ::grpc::MessageAllocator< ::minidfs::FileLockReq, ::minidfs::FileLockRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minidfs::FileLockReq, ::minidfs::FileLockRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileLock(
      ::grpc::CallbackServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minidfs::DeleteFileReq, ::minidfs::DeleteFileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minidfs::DeleteFileReq* request, ::minidfs::DeleteFileRes* response) { return this->RemoveFile(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveFile(
        ::grpc::MessageAllocator< ::minidfs::DeleteFileReq, ::minidfs::DeleteFileRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minidfs::DeleteFileReq, ::minidfs::DeleteFileRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minidfs::FileUpdate, ::minidfs::FileUpdate>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minidfs::FileUpdate* request) { return this->FileUpdateCallback(context, request); }));
    }
    ~WithCallbackMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minidfs::FileUpdate>* FileUpdateCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ListFiles<WithCallbackMethod_StoreFile<WithCallbackMethod_FetchFile<WithCallbackMethod_GetFileLock<WithCallbackMethod_RemoveFile<WithCallbackMethod_FileUpdateCallback<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListFiles() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StoreFile() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StoreFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::minidfs::FileBuffer>* /*reader*/, ::minidfs::StoreFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFileLock() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveFile() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListFiles() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StoreFile() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_StoreFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::minidfs::FileBuffer>* /*reader*/, ::minidfs::StoreFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchFile() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFileLock() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileUpdateCallback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListFiles() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListFiles(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StoreFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StoreFile() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->StoreFile(context, response); }));
    }
    ~WithRawCallbackMethod_StoreFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::minidfs::FileBuffer>* /*reader*/, ::minidfs::StoreFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* StoreFile(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FetchFile() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->FetchFile(context, request); }));
    }
    ~WithRawCallbackMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* FetchFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFileLock() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFileLock(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileLock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->FileUpdateCallback(context, request); }));
    }
    ~WithRawCallbackMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* FileUpdateCallback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListFiles() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minidfs::ListFilesReq, ::minidfs::ListFilesRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minidfs::ListFilesReq, ::minidfs::ListFilesRes>* streamer) {
                       return this->StreamedListFiles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::minidfs::ListFilesReq* /*request*/, ::minidfs::ListFilesRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minidfs::ListFilesReq,::minidfs::ListFilesRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFileLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFileLock() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minidfs::FileLockReq, ::minidfs::FileLockRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minidfs::FileLockReq, ::minidfs::FileLockRes>* streamer) {
                       return this->StreamedGetFileLock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFileLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFileLock(::grpc::ServerContext* /*context*/, const ::minidfs::FileLockReq* /*request*/, ::minidfs::FileLockRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFileLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minidfs::FileLockReq,::minidfs::FileLockRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveFile() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minidfs::DeleteFileReq, ::minidfs::DeleteFileRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minidfs::DeleteFileReq, ::minidfs::DeleteFileRes>* streamer) {
                       return this->StreamedRemoveFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::minidfs::DeleteFileReq* /*request*/, ::minidfs::DeleteFileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minidfs::DeleteFileReq,::minidfs::DeleteFileRes>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ListFiles<WithStreamedUnaryMethod_GetFileLock<WithStreamedUnaryMethod_RemoveFile<Service > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_FetchFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_FetchFile() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minidfs::FetchFileReq, ::minidfs::FileBuffer>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minidfs::FetchFileReq, ::minidfs::FileBuffer>* streamer) {
                       return this->StreamedFetchFile(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_FetchFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchFile(::grpc::ServerContext* /*context*/, const ::minidfs::FetchFileReq* /*request*/, ::grpc::ServerWriter< ::minidfs::FileBuffer>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedFetchFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minidfs::FetchFileReq,::minidfs::FileBuffer>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_FileUpdateCallback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_FileUpdateCallback() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minidfs::FileUpdate, ::minidfs::FileUpdate>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minidfs::FileUpdate, ::minidfs::FileUpdate>* streamer) {
                       return this->StreamedFileUpdateCallback(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_FileUpdateCallback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FileUpdateCallback(::grpc::ServerContext* /*context*/, const ::minidfs::FileUpdate* /*request*/, ::grpc::ServerWriter< ::minidfs::FileUpdate>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedFileUpdateCallback(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minidfs::FileUpdate,::minidfs::FileUpdate>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_FetchFile<WithSplitStreamingMethod_FileUpdateCallback<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_ListFiles<WithSplitStreamingMethod_FetchFile<WithStreamedUnaryMethod_GetFileLock<WithStreamedUnaryMethod_RemoveFile<WithSplitStreamingMethod_FileUpdateCallback<Service > > > > > StreamedService;
};

}  // namespace minidfs


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_minidfs_2eproto__INCLUDED
